module MainMem where

import Prelude
import Math
import Data.Sequence as S
import Data.Maybe
import Data.Int.Bits
import Data.Array as A

import Types

-- 8 Bit version

-- 8 Bit version

setRom :: Array I8 -> MainMem -> MainMem
setRom rom (MainMem mem) = MainMem $ mem { rom = rom }

--NOTE: toggle inbios when pc == 0x0100
rd8 :: I16 -> MainMem -> I8
rd8 addr (MainMem mem) =
  fromMaybe 0 $ S.index addr mem

--NOTE make sure the significant byte part sits at a higher address
rd16 :: I16 -> MainMem -> I16
rd16 addr (MainMem mem) = (h `shl` 8) + l
 where
  l = fromMaybe 0 $ S.index addr mem
  h = fromMaybe 0 $ S.index (addr + 1) mem

wr8 :: I8 -> I16 -> MainMem -> MainMem
wr8 i8 addr (MainMem mem) = MainMem $ S.replace i8 addr mem

wr16 :: I16 -> I16 -> MainMem -> MainMem
wr16 i16 addr (MainMem mem) = MainMem $
      S.replace h (addr + 1)
  <<< S.replace l addr
   $  mem
 where
  h = 255 .&. (i16 `zshr` 8)
  l = 255 .&. i16

--16 Bit version

--NOTE consider splitting the mems to a generic number of chunks N
--that you can easily change, and then profile the performance for different N
--Or consider using array ST, if in need of better performance

--memory address
{--0 1 2 3 4 ...--}
{--0 0 1 1 2 ...--}
--seq index

{--the quotient is the index--}
{--the remainder is the offset inside the chunk--}
--Chunk size in bytes
{--chkSz :: Int--}
{--chkSz = 2--}

{--cleanMainMem :: MainMem--}
{--cleanMainMem = MainMem $ S.fromFoldable $ A.replicate size 0--}
 {--where--}
  {--size = 65536 / chkSz--}

{--rd8 :: I16 -> MainMem -> I8--}
{--rd8 addr (MainMem mem) = lsByteOf $--}
  {--(if isShiftNeeded then shiftByte else id) i16--}
 {--where--}
  {--isShiftNeeded = addr `mod` 2 == 0--}
  {--i16 = fromMaybe 0 $ S.index (addr / chkSz) mem--}
  {--shiftByte x = x `zshr` 8--}
  {--lsByteOf x = x .&. 255--}

{----NOTE replace all 'fromMaybe's with an error mechanism that will make it easy--}
{----to trace Nothing cases--}
{--rd16 :: I16 -> MainMem -> I16--}
{--rd16 addr (MainMem mem) = fromMaybe 0 $ S.index (addr / chkSz) mem--}

{--wr8 :: I8 -> I16 -> MainMem -> MainMem--}
{--wr8 i8 addr (MainMem mem) = MainMem $ S.adjust adjByte (addr / chkSz) mem--}
 {--where--}
  {--adjByte = (_ .|. i8') <<<--}
    {--(_ .&. if isShiftNeeded then 255 else 65535 - 255)--}
  {--i8' = (if isShiftNeeded then shiftByte else id) i8--}
  {--isShiftNeeded = addr `mod` 2 == 0--}
  {--shiftByte x = x `shl` 8--}

{--wr16 :: I16 -> I16 -> MainMem -> MainMem--}
{--wr16 i16 addr (MainMem mem) = MainMem $ S.replace i16 (addr / chkSz) mem--}
cleanMainMem :: MainMem
cleanMainMem = initMem $ MainMem
  { biosMapped : false
  , rom  : A.singleton 0
  , eram : S.fromFoldable $ A.replicate 8192 0
  , wram : S.fromFoldable $ A.replicate 8192  0
  , zram : S.fromFoldable $ A.replicate 128 0
  , gpu  : cleanGpu
  , bios :  [
    0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32,
    0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
    0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3,
    0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
    0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A,
    0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
    0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06,
    0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
    0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99,
    0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
    0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64,
    0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
    0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90,
    0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
    0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62,
    0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
    0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xF2, 0xF0, 0x42,
    0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
    0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04,
    0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
    0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9,
    0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
    0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D,
    0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
    0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99,
    0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
    0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E,
    0x3c, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x4C,
    0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13,
    0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
    0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20,
    0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50
  ]
  }
 where
  initMem =
          wr8 0xD8 0xCFF7 
      <<< wr8 0xD8 0xEFF7
      <<< wr8 0x80 0xCFFB 
      <<< wr8 0x80 0xEFFB
      <<< wr8 0x3B 0xCFFD 
      <<< wr8 0x3B 0xEFFD
      <<< wr8 0x03 0xCFFE 
      <<< wr8 0x03 0xEFFE

      <<< wr8 0x03 0xDF78 

      <<< wr8 0x80 0xFF40
      <<< wr8 0x87 0xFF41
      <<< wr8 0xE4 0xFF47
      <<< wr8 0xE4 0xFF48
      <<< wr8 0xC4 0xFF49
      <<< wr8 0xFF 0xFF4C
      <<< wr8 0x7E 0xFF4D
      <<< wr8 0xFF 0xFF4E
      <<< wr8 0xFE 0xFF4F
      <<< wr8 0xFF 0xFF50
      <<< wr8 0xFF 0xFF55
      <<< wr8 0xC0 0xFF68
      <<< wr8 0xC1 0xFF6A
      <<< wr8 0xF8 0xFF70

      <<< wr8 0x3E 0xFFB6
      <<< wr8 0xC0 0xFFB7
      <<< wr8 0xE0 0xFFB8
      <<< wr8 0x46 0xFFB9
      <<< wr8 0x3E 0xFFBA
      <<< wr8 0x28 0xFFBB
      <<< wr8 0x3D 0xFFBC
      <<< wr8 0x20 0xFFBD
      <<< wr8 0xFD 0xFFBE
      <<< wr8 0xC9 0xFFBF
      <<< wr8 0x37 0xFFC0
      <<< wr8 0x1C 0xFFC1
      <<< wr8 0x24 0xFFE1
      <<< wr8 0x09 0xFFFF


